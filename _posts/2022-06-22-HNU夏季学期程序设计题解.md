---
layout:     post
title:      HNU 夏季学期「程序设计训练 2022」 课程题解
subtitle:   仅供参考
date:       2022-06-22
author:     Rain Chen
catalog: true
tags:
    - 开发与应用
---

Contents
- unordered list
{:toc}

# HNU 夏季学期「程序设计训练 2022」 课程题解

## 前言

> 「输入两个整数 a 和 b，输出它们的和。」
>           —— A+B Problem

本题解中的题目描述文字格式全部按照题目原文，描述部分的排版和题解作者无关。

## 代码

代码项目和文件存放于仓库中，题解中有每道题对应的链接。

[https://github.com/Chen-Rain/Pitaya](https://github.com/Chen-Rain/Pitaya)

如果无法打开请自行检查网络配置。

## 作业训练一

### Problem 01. 众数

#### 题目部分

【问题描述】

一组数据中出现最多的数，称为众数。比如

1 2 3 3

众数为3。一组数据中也可能有多个众数，以最先出现的作为众数。比如

2 2 3 3

众数为2。

问题是一组按升序排好的数据，指出它的众数。

【输入形式】

有多组测试数据（不超过100组测试数据）。

每组测试数据占两行，第一行是正整数N：表示这组测试数据中数据项数。

第二行是N个用空格隔开的正整数，表示这组测试数据的数据元素。每个数据元素都不大于10000。

N=0，表示输入结束，并且不需要处理。

40%的测试数据N 1 ≤N≤ 10；

30%的测试数据N 10 < N≤ 100；

20%的测试数据N 100 < N≤ 1000；

10%的测试数据N 1000 < N≤ 10000；

【输出形式】

对于每组测试数据，输出一行包含一个正整数：对应的众数。

【样例输入】

```
4
1 2 3 3
4
2 2 3 3
0
```

【样例输出】

```
3
2
```

#### 题解部分

【思路】

用整型数组存储输入的要求众数的数据。根据单独输入的数字 `n` 来确定动态数组的大小。由于数组已经升序排列好了，所以不用考虑数字大小关系的问题。新建一个数组 `c[i]` 用于存储数字 `i` 的众数，这个数组应当开大一些，确保测试数据规模中的所有数字都可以在其中表示。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P01)

- [Python 3](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P01-python)

【遇到的一些问题】

就是这 Python 的输入问题有点不方便。如果一定要使用 Python 答题的话需要仔细调整输入方式，防止在本地测试的时候可以通过，但是提交之后 WA。

### Problem 02. 开关与灯

#### 题目部分

【问题描述】

给定n个开关和m个灯，第i个开关只能打开部分灯。矩阵a包含n行m列，当aij=1时表示开关i可以打开灯j，否则aij=0。

开始时所有的m个灯都是关着的。

开关只能从状态"关"到"开"。这意味着，对于每个可以打开某个灯的开关，无论你按多少次，这个灯都是开的。

确保当你按下所有开关时，所有的灯都能打开，考虑是否可以忽略其中某个开关也能打开所有的灯。

你的任务是确定是否存在这样的开关可以忽略，而使用其余的n-1个开关来打开所有m个灯。

【输入形式】

输入第1行包含两个整数n和m(1<=n, m<=2000)，表示开关的数量和灯的数量。

接下来的n行，每行包含m个字符，字符aij=1时表示开关i可以打开灯j，否则aij=0。

【输出形式】

如果存在这样的可以忽略的开关，而使用其他n-1个开关打开所有的m个灯，输出"YES"，否则输出"NO"。

【样例输入】

```
4 5
10101
01000
00111
10000
```

【样例输出】

```
YES
```

#### 题解部分

【思路】

使用矩阵来存储开关与灯的对应关系，横向输入的时候可以用字符数组，也可以用字符串。然后每一列判断可以开灯的个数。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P02)

【遇到的一些问题】

这道题容易出错的一点是，以为只要有矩阵的一列的数量大于 1 就可以满足去掉的条件，实际上还是要注意要判断去掉那一行之后还能不能保证所有的灯全部亮。

### Problem 03. 可删除的点

#### 题目部分

【问题描述】

平面上有n个不同的点，没有在Y轴的点，检查是否存在这样一个点，将其删除后其余所有的点均位于Y轴的同一边。

【输入形式】

输入第一行包含一个正整数n(2<=n<=105)。

接下来的n行，包含所有点的坐标，第i行包含两个整数xi和yi(|xi|、|yi|<=109，xi<>0)。

【输出形式】

如果存在这样的点，则输入"Yes"，否则输出"No"。

【样例输入】

```
3
1 1
-1 -1
2 -1
```

【样例输出】

```
Yes
```

#### 题解部分

【思路】

均在 y 轴同一边的点满足 x 轴全是正数或者全是负数。所以输入的时候最少只需要给一个变量存储所有点的 y 坐标即可，不用处理。对所有点的 x 坐标进行判断，设立一个变量记录一边的点的数量。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P03)

【可能出错的地方】

「在 y 轴的同一边」到底是比较 x 坐标还是比较 y 坐标呢？

### Problem 04. 字符串反转 3

#### 题目部分

【问题描述】

给出一个字符串，请将其每个单词反转后输出。

【输入形式】

输入第一行为一个正整数N，表示测试用例数，接下来的N行，每行一个字符串。

【输出形式】

输出N行，每行对应一个反转后的字符串。

【样例输入】

```
3
olleh !dlrow
m'I morf .unh
I ekil .tae
```

【样例输出】

```
hello world!
I'm from hnu.
I like eat.
```

#### 题解部分

【思路】

第一眼，喔，经典字符串反转。第二眼，喔还带空格，要考虑一下输入问题。然后反转字符串第一时间想到的就是可以使用「栈」，`stack`，不过如果你第一感觉是用 `reverse()` 函数，那也没问题，不过就要考虑分段的问题了。这道题我提交的解法是使用了 `stack`，把字符串中的每一个字符进行判断，然后推入栈中，遇到空格的时候说明应该分词了，就把栈弹出，直至清空整个栈，如此往复至处理完所有数据。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P04)

【可能遇到的问题】

在使用 C++ 解答的时候，注意栈的大小，小心遗漏。使用 Python 解答的时候注意字符串输入的时候的问题，容易出现格式和数据类型对不上的问题。

### Problem 05. n，还是n

#### 题目部分

【问题描述】

输出 包含n 或者是n的倍数的所有数。

【输入形式】

正整数 m,n（0 < m，n<1000000）

【输出形式】

从小到大排列的不大于 m 的特殊正整数（包含n，或者是n的倍数）。

【样例输入 1】

```
20 7
```

【样例输出 1】

```
7 14 17
```

【样例输入 2】

```
200 11
```

【样例输出 2】

```
11 22 33 44 55 66 77 88 99 110 111 112 113 114 115 116 117 118 119 121 132 143 154 165 176 187 198
```

【样例说明】

包含n的数可以考虑使用字符串查找解决

#### 题解部分

【思路】

首先查找字符串，如果找到就直接输出；如果没有找到再考虑整除。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P05)

【可能遇到的问题】

如果使用每一位数字对 10 取模的方法来判断的话就没有办法找到数字中包含两位或两位以上的给定数字的数，无法通过全部样例。

### Problem 06. 字符串排序

#### 题目部分

【问题描述】

定义一个字符串的无序度为所有位置后面的字母比该位置的字母小的总数之和。比如"DAABEC''这个字符串的无序度是5，因为D后面有4个位置比它小（AABC），E后面有1个比它小（C），其它位置后面没有比自己小的。" AACEDGG "的无序度为1（E后面有一个D比它小）。" ZWQM "的无序度为6，每个位置后面所有的字母都比它小。
现在你的任务是给定一些字符串（只由大写字母组成），把他们按照无序度从小到大排序，如果无序度一样，那么就按照输入的相对顺序排序。

【输入形式】

单组测试数据。
第一行有两个整数n(0 < n <= 50)和m (0 < m <= 100)，分别表示输入的字符串的长度和字符串的个数。
接下来m行，每一行包含一个长度为n的字符串，只由大写字母组成。

【输出形式】

输出m行，表示排序之后的字符串。

【样例输入】

```
10 6
AACATGAAGG
TTTTGGCCAA
TTTGGCCAAA
GATCAGATTT
CCCGGGGGGA
ATCGATGCAT
```

【样例输出】

```
CCCGGGGGGA
AACATGAAGG
GATCAGATTT
ATCGATGCAT
TTTTGGCCAA
TTTGGCCAAA
```

#### 题解部分

【思路】

无序度的算法可以是冒泡排序的思路。在数据存储方面，建立了结构体来存储字符串和对应的无序度。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P06)

### Problem 07. 三角形的面积

#### 题目部分

【问题描述】

已知三角形的三个顶点的坐标，求该三角形的面积。

【输入形式】

有多组测试数据。

每组测试数据占一行，6个用空格分隔开的浮点数：x1,y1,x2,y2,x3,y3。表示三角形三个顶点的坐标。

一行6个0（形如0 0 0 0 0 0），表示输入结束，并且不需要处理。

40%的顶点坐标 -10 ≤ xi,yi≤ 10；i=1,2,3

30%的顶点坐标 -100 ≤ xi,yi≤ 100；i=1,2,3

20%的顶点坐标 -1000 ≤ xi,yi≤ 1000；i=1,2,3

10%的顶点坐标 -10000 ≤ xi,yi≤ 10000；i=1,2,3

【输出形式】

对于每组测试数据，输出对应三角形面积，保留小数点后6位。

【输入样例】

```
1 2 3 4 -2 8
0 0 0 1 1 0
0 0 0 0 0 0
```

【输出样例】

```
9.000000
0.500000
```

【解题技巧】

海伦公式、向量叉乘

#### 题解部分

【思路】

解题技巧已经提到了，计算三角形面积可以使用海伦公式，在这个题里面是一种比较简单的方式。海伦公式如下：

$ p = \frac{a + b + c}{2} $，$ S = \sqrt{p(p - a)(p - b)(p - c)} $

另外，技巧提示里说的向量叉乘好像没有用到（？），不确定。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P07)

【容易遇到的问题】

保留 6 位小数；另外做除法运算的时候要确保是浮点型数据在运算，否则只能得到整除的结果。

### Problem 08. 循环数

#### 题目部分

【问题描述】

循环数是n位长度的整数，当乘以从1到n的任何整数时，产生原始数字的“循环”。也就是说，如果考虑最后一个数字之后的数字“绕”回到第一个数字，两个数字中的数字序列将是相同的，尽管它们可能从不同的位置开始。例如，数字142857是循环的，如下表所示： 

142857 *1 = 142857
142857 *2 = 285714
142857 *3 = 428571
142857 *4 = 571428
142857 *5 = 714285
142857 *6 = 857142 

编写一个程序来确定数字是否是循环数。

【输入形式】

输入一个数，长度在2到60位之间(请注意，前面的零不应该被删除，它们被认为是确定n的大小和计数的一部分，因此，“01”是一个两位数的数字，与“1”是一个一位数的数字不同。) 。

【输出形式】

对于每个输入，输出一行(Yes或No)标识它是否是循环数。 

【样例输入】

```
142857
```

【样例输出】

```
Yes
```

【特别感谢】

特别感谢计科 2101 班 lsk 同学提供的测试数据集导致部分同学的使用数字进行处理的代码直接 WA 了。

#### 题解部分

【思路】

用字符串存储要判断的数字串，然后把它变成两倍连在一起，用数字分别加倍，在两倍长的字符串中寻找子串，如果都能找到，说明是循环数。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P08)

### Problem 09. 电能消耗

#### 题目部分

【问题描述】

汤姆对他最喜欢的笔记本电脑的耗电量很感兴趣。他的笔记本电脑有三种模式。在正常模式下，笔记本电脑每分钟消耗P1瓦。在汤姆最后一次移动鼠标或触摸键盘后的T1分钟，屏幕保护程序启动，每分钟的功耗变化为P2瓦。最后，从屏幕保护程序启动到T2分钟后，笔记本电脑切换到“睡眠”模式，每分钟消耗P3瓦。 当笔记本电脑处于第二或第三模式时，如果汤姆移动鼠标或触摸键盘，则切换到第一种(正常)模式。 汤姆使用笔记本电脑工作的时间可以分为n个时间间期[l1, r1]、[l2, r2]、...、[ln, rn]。在每个间期，汤姆连续移动鼠标并按下键盘。 在间期之间，汤姆什么都不做。请找出在间期[l1, rn]笔记本电脑的总耗电量。

【输入形式】

第一行包含6个整数n、P1、P2、P3、T1、T2(1<=n<=100，0<=P1、P2、P3<=100，1<=T1、T2<=60)。接下来的n行包含了汤姆工作的期间，第i行是两个用空格分隔的整数li和ri(0<=li<=ri<=1440, 当i< n时ri< li+1）, 表示工作期间的开始时间和结束时间。

【输出形式】

输出总的耗电量。

【输入样例】

```
2 8 4 2 5 10
20 30
50 100
```

【输出样例】

```
570
```

#### 题解部分

【思路】

> 稍后补充

【Accepted 代码】

-  [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P09)

### Problem 10. IP 地址

#### 题目部分

【问题描述】

一个IP地址由32位二进制的数组成，比如：

11111111111111111111111100000000（2）

为了便于记忆，我们将8个二进制位用一个十进制数表示，一个IP地址由四个十进制数表示，上述的IP地址表示为：

255.255.255.0

现在给你一个上述形式的IP地址，请回答IP地址的32个二进制位中，有多少位是1。

如IP地址为255.255.255.0，其中24位是1。

【输入形式】

有多组测试数据。

测试数据第一行是一个正整数T，表示测试数据组数。

每组测试数据是一个IP地址，形式为：

IP1.IP2.IP3.IP4

其中0 ≤IP1,IP2,IP3,IP4≤ 255,用十进制表示。每个IP地址不保证是实用IP地址。

40%的测试数据组数T  10≤T≤ 102；

30%的测试数据组数T  102≤T≤ 103；

20%的测试数据组数T  103≤T≤ 104；

10%的测试数据组数T  104≤T≤ 105；

【输出形式】

对于每个IP地址，输出一行包含一个非负整数：该IP地址的32个二进制位中，1的位数。

【样例输入】

```
5
255.255.255.0
127.0.0.1
0.0.0.1
1.2.3.4
0.0.0.0
```

【样例输出】

```
24
8
1
5
0
```

#### 题解部分

【思路】

读入 IP 地址，分成四个十进制的整数，然后分别转换成二进制数，统计总的数字 1 的个数。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P10)

【可能遇到的问题】

怎么把这个 IP 地址分成四个整数？截取一小段[我](https://github.com/Chen-Rain)和 [@Brick](https://github.com/Brick-Loo) 聊天记录如下：

Rain: 话说怎么输入一串数字的时候用「.」分隔开几个整数？

Brick: 没懂你意思，就是说用.代替空格来分隔数字？

Rain: 对

Rain: 比如这样，123.456.789.10

Rain: 我要把这几个数提取出来

Brick: 唔，用 get 函数？

Brick: 我印象中有一个重载是可以设置分隔符的

Brick: 或者你直接一个一个 peek 看看是不是点 /doge（离谱型做法）

Brick: （这个应该不行吧）

Brick: 不过这样的话

Brick: 喔喔 get 好像可以

Rain: 你这个我 peek 完之后还要把它搞成一个数字啊喂

Rain: 好 我吃完饭看看

Brick: /doge

Brick: 那可以直接存进数组然后再用 ASCII 偏移和位数加进一个 int 里面 /doge

Brick: 太骚了

Brick: 指 peek 的方法

Rain: 那我考虑一下这个

Rain:
```cpp
for (char &i : s) {
    getchar(i);
}
```

Rain: /emoji

Brick: 诶

Brick: 其实可以整个串读到一个数组

Brick: 然后从最后开始

Brick: 往前

Brick: 如果是数字的话就乘个 10 再加进来

Brick: 如果不是数字对话就再往前一位存到新的 int 里面

Brick: 你是这个意思吗（引用那串代码）

Rain: 我是一个字符一个字符的读取

Rain: 诶 好像是这个意思

然后过了一个晚上……

Rain: @Brick 我们好像想复杂了

Rain: 这不就直接把点给搞掉了嘛

```c
scanf("%d.%d.%d.%d", &a, &b, &c, &d);
```

Rain: 垃圾吸艹

Brick: ？？？

Brick: 没学过这种操作

Brick: 还是 c 比较牛

Rain: 如果这个点换成其他字符也 OK

Rain: 诶 完美（）

Brick: 好活 看来我假期得学手 c

所以我一开始绕了一大圈，绕过了从输入的方法上解决数字分段的问题……但是后来又仔细一想，C++ 里面也有这种输入方式，只要用一个字符变量存储点就行了……

属实离谱。

### Problem 11. 平均方差

#### 题目部分

【问题描述】

一个数列的平均方差是指数列中的每个元素与数列的平均值的差的平方和的平均值，比如下面数列：

1 2 3 4 5 6 7

其平均值为4，每个元素与平均值的差的平方为

9 4 1 0 1 4 9

其平方和为28，所以该数列的平均方差为4。

对给定的数列，求出其平均方差。

【输入形式】

有多组测试数据。

每组测试数据第一行是一个正整数N，表示数列中元素个数，接下来一行N个用空格分隔开的正整数，表示数列的N个元素，每个元素的值都是不大于500的正整数。

N=0表示输入结束，并且不需要处理。

40%的数列元素个数N 1 ≤ N≤ 10；

30%的数列元素个数N 1 ≤ N≤ 100；

20%的数列元素个数N 1 ≤ N≤ 1000；

10%的数列元素个数N 1 ≤ N≤ 10000；

【输出形式】

对于每组测试数据，输出一个整数：平均方差。平均方差不是整数的，输出其向下取整的整数。比如平均方差是4.5，输出4。

【样例输入】

```
7
1 2 3 4 5 6 7
4
1 2 3 4
0
```

【样例输出】

```
4
1
```

#### 题解部分

【思路】

> 这是一个水题。 —— OI 名言

按着题目的方法算就行了，用一两个循环，可以解决。用 Python 的选手注意一下把输入的循环控制住，用 C++ 的选手注意把整数和浮点数的运算处理好。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P11)

### Problem 12. 内存管理

#### 题目部分

【问题描述】

离第一个操作系统HNU-OS发布已经没有多少时间了，但它的一些组件还没有完成，内存管理器就是其中之一。根据开发人员的计划，在第一个版本中，内存管理器将非常简单和直观。它将支持三个操作： 

alloc n —— 分配n个字节内存，返回已分配块的正整数标识符x(x初始值为0，每次分配增长1)

erase x —— 删除标识符x所在的块

defragment —— 整理空余内存碎片，将所有块尽量靠近内存的开始位置，并保持各自的顺序

在此情况下，内存模型非常简单，它是一个m字节的序列，为了方便起见，从第一个字节到第m字节进行编号。

第一个操作alloc n有一个参数n，表示被分配的内存块大小。在处理此操作时，内存中将分配n个连续字节的空闲块。 如果这些块的数量超过一个，则优先选择最接近内存开始(即第一个字节)的块。 所有这些字节都被标记为非空闲，内存管理器返回一个32位整数数字令牌，代表该块的标识符。 如果不可能分配这样大小的空闲块，则返回NULL。

第二个操作erase x以x为参数，表示某个块的标识符。此操作释放系统内存，将此块的字节标记为空闲以供进一步使用。 如果此标识符没有指向先前分配的块(该块尚未被释放)，则返回ILLEGAL_ERASE_ARGUMENT。

最后一个操作defragment没有任何参数，只会使占用的内存部分更接近内存的开始，而不会更改它们各自的顺序。 

在当前的实现中，将使用从1开始的连续整数作为标识符。每个成功的alloc操作过程都应该返回接下来的编号。不成功的alloc操作不影响计数。 

编写内存管理器的实现，为每个alloc命令输出返回的值，为所有失败的erase命令输出ILLEGAL_ERASE_ARGUMENT。 

【输入形式】

输入数据的第一行包含两个正整数t和m（1<=t<=500, 1<=m<=105)，其中t表示需要内存管理器来处理的操作个数，m表示有效的内存字节大小。接下来的t行每一行代表一个操作。

【输出形式】

输出有多行，每行或者是alloc操作的结果，或者是失败的erase操作的结果ILLEGAL_ERASE_ARGUMENT。其顺序与输入的操作次序一致。

【样例输入】

```
6 10
alloc 5
alloc 3
erase 1
alloc 6
defragment
alloc 6
```

【样例输出】

```
1
2
NULL
3
```

#### 题解部分

【思路】

> 稍后补充

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T01P12)

【遇到的问题】

> 问题很多，稍后慢慢填坑

## 作业训练二

### Problem 01. 字符串反转2

#### 题目部分

【问题描述】

给定一个句子（只包含字母和空格）， 将句子中的单词位置反转，单词用空格分割, 单词之间只有一个空格，前后没有空格。 比如： “hello xiao mi”-> “mi xiao hello”

【输入形式】

输入数据有多组，每组占一行，包含一个句子(句子长度小于1000个字符)

【输出形式】

对于每个测试示例，要求输出句子中单词反转后形成的句子

【样例输入】

```
hello xiao mi
I am a student
```

【样例输出】

```
mi xiao hello
student a am I
```

#### 题解部分

【思路】

这道题可以使用常规的字符串反转的思路，也可以用一些奇奇怪怪的方法。一种方法是使用 `vector` 存储字符串中的每一段（词组）；或者像我一样这道题采用直接先把整个字符串反转 `reverse()` 后再逐个单词反转回来的方法。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P01)
- [最大规模数据集随机生成程序：测试用](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P01-testing)

【可能遇到的问题】

注意输出时的空格控制，防止出现格式错误。

### Problem 02. xxx定律

#### 题目部分

【问题描述】

对于一个正整数n，如果是偶数，就把n砍掉一半；如果是奇数，把n变成 3*n+ 1后砍掉一半，直到该数变为1为止。
请计算需要经过几步才能将n变到1，具体可见样例。

【输入形式】

测试包含多个用例，每个用例包含一个整数n,当n为0 时表示输入结束。（1<=n<=10000）

【输出形式】

对于每组测试用例请输出一个数，表示需要经过的步数,每组输出占一行。

【样例输入】

```
3
2
0
```

【样例输出】

```
5
1
```

#### 题解部分

【思路】

这道题应该是一个数学问题，放进「数学」的 Tag 里面（不是）。只用按照题目的步骤操作就行。对每一个数进行操作，遇到 `0` 退出程序就行。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P01)

【可能遇到的问题】

注意控制循环开始和结束的条件，不要越界了。

### Problem 03. 数的距离差

#### 题目部分

【问题描述】

给定一组正整数，其中最大值和最小值分别为Max和Min, 其中一个数x到Max和Min的距离差定义为：

abs(abs(x-Max)-(x-Min))

其中abs()为求一个数的绝对值

【输入形式】

包括两行，第一行一个数n，表示第二行有n个正整数

【输出形式】

输出一个数x，该数在所有n个数中的距离差最小；如果有两个数的距离差都是最小，输出较小的哪个

【样例输入 1】

```
5
3 1 7 5 9
```

【样例输出 1】

```
5
```

【样例输入 2】

```
3
1 3 2
```

【样例输出 2】

```
2
```

#### 题解部分

【思路】

好像也是一个纯数学问题。按照题目的步骤操作就行。计算一组数的和、平均值、每一个数与平均值的差等等。可以开两个动态数组 `array` 来存储原来的一组数和每一个数对应与平均值的差。当然使用 `vector` 也没有问题，用着顺手就好。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P03)

【容易出错的问题】

C++ 和 Python 的浮点数除法运算输出结果的问题。总结如下表：

| 运算\语言 | C++ | Python 2 | Python 3 |
| --- | --- | --- | --- |
| `4 / 2` | `2` | `2` | `2` |
| `5 / 2` | `2` | `2` | `2.5` |
| `5.0 / 2` | `2.5` | `2.5` | `2.5` |

### Problem 04. 亲和数

#### 题目部分

【问题描述】

古希腊数学家毕达哥拉斯在自然数研究中发现，220 的所有真约数(即不是自身的约数)之和为：   

1+2+4+5+10+11+20+22+44+55+110＝284。

而 284 的所有真约数为 1、2、4、71、 142，加起来恰好为 220。人们对这样的数感到很惊奇，并称之为亲和数。一般地讲，如果两个数中任何一个数都是另一个数的真约数之和，则这两个数就是亲和数。

你的任务就编写一个程序，判断给定的两个数是否是亲和数。

【输入形式】

输入若干行数据（大于0），每行一个实例,包含两个整数A,B； 其中 0 <= A,B <= 600000 ;

【输出形式】

对于每个测试实例，如果 A 和 B 是亲和数的话输出 YES，否则输出 NO

【样例输入】

```
220 284
100 200
```

【样例输出】

```
YES
NO
```

#### 题解部分

【思路】

分别求两个数的「真约数」，判断是否等于对方。使用循环即可解决，这道题的数据规模不会导致双重循环超时 `Time Limit Exceeded` 的问题。这个题有一个情景不同，内核相同的变种，是 2021 秋季学期的「程序设计」课程的一个作业题：「牛数」（好像是叫这个名？）。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P04)

【需要注意的问题】

两个数的真约数求和跟两个数的真约数本身不要搞混了。

### Problem 05. 金币

#### 题目部分

【问题描述】

国王为他的忠诚的骑士支付金币。在他服役的第一天，骑士收到一枚金币。在接下来2天（第二天和第三天的服务），骑士每天收到2金币。在未来三天（第五，第四，和第六天的服务），骑士每天收到三金币。在未来四天（第七，第八，第九，和第十天的服务），骑士每天收到四金币。这一模式的付款方式将继续下去：在接下来的n天骑士每天将收到n枚金币，而在接接下来的n+1天每天将收到n+1枚金币，这里n是正整数。你的程序将确定在任何给定的天数（从第1天开始）支付给骑士的金币总数。

【输入形式】

输入包含至少一行，但不超过21行。输入的每一行包含一个测试案例的数据，即一个整数（1~10000），代表天数。

【输出形式】

每一行输出对应一个测试用例，由天数和支付给骑士的金币总数量组成，中间用空格分隔。

【样例输入】

```
10
6
10000
1000
21
22
```

【样例输出】

```
10 30
6 14
10000 942820
1000 29820
21 91
22 98
```

#### 题解部分

【思路】

用一个变量对当前天数进行计数，控制发金币的天数。用另外一个变量对发相同数量的金币的天数进行计数，控制相同金币天数形成一个等差数列。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P05)

【需要注意的问题】

需要多个计数变量，分别统计天数，不要弄混了。

### Problem 06. 小A的计算器

#### 题目部分

【题目描述】

以往的操作系统内部的数据表示都是二进制方式，小A新写了一个操作系统，系统内部的数据表示为26进制，其中0-25分别由a-z表示。
现在小A要在这个操作系统上实现一个计算器，这个计算器要能实现26进制数的加法运算。你能帮小A实现这个计算器吗？

【输入形式】

输入的第一行包括一个整数N(1<=N<=100)。
接下来的N行每行包括两个26进制数x和y，它们之间用空格隔开，每个数的位数最多为10位,我们可以保证相加的结果的位数最多也是10位。每个数会用小A所设计的操作系统中的表示方法来表示，如：bsadfasdf。即每个数的各个位均由26个小写字母a-z中的一个来表示。

【输出形式】

输出x和y相加后的结果，结果也要用题目中描述的26进制数来表示。

【样例输入】

```
4
ba cd
c b
b c
ba c
```

【样例输出】

```
dd
d
d
bc
```

#### 题解部分

【思路】

> 懒得写

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P06)

【需要注意的问题】

注意字符串和字符数组的处理。

### Problem 07. 小丑排序

#### 题目部分

【问题描述】

你在信天翁马戏团（是的，它是由一群小丑组成）从事管理工作，你刚刚写完一个程序的输出是将他们的姓名按长度为非递减的方式排列，名称列表（使每名至少只要它之前的）。然而，你的老板不喜欢这种输出方式，而是希望输出出现更对称，较短的字符串在顶部和底部，而较长的字符串在中间。他的规则是，每一对名称都是在该列表的相对的两端，并且在该组中的第一个名字总是在列表的顶部。比如在下面的第一个例子中，Bo和Pat是第一对，Jean和Kevin是第二对，等等。

【输入形式】

输入由1到多个字符串集合组成，最后一行为0表示输入结束，每个集合开始于一个整数n，表示该集合字符串的个数，接下来n行由n个字符串按长度非递减的方式排列，每个集合至少包含一个但不超过15个字符串，每个字符串不超过25个字符。

【输出形式】

对于每个集合，第一行输出"set-n", n从1开始，接下来的若干行对应输入每个集合重新排列的结果，如样例所示。

【样例输入】

```
7
Bo
Pat
Jean
Kevin
Claude
William
Marybeth
6
Jim
Ben
Zoe
Joey
Frederick
Annabelle
5
John
Bill
Fran
Stan
Cece
0
```

【样例输出】

```
set-1
Bo
Jean
Claude
Marybeth
William
Kevin
Pat
set-2
Jim
Zoe
Frederick
Annabelle
Joey
Ben
set-3
John
Fran
Cece
Stan
Bill
```

#### 题解部分

【思路】

按从上到下的顺序，奇数位置的名字从上往下排，偶数位置的名字从下往上排，最后直接输出整组数据就行。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P07)

【需要注意的问题】

C++ Standard Template Library 中 `stack` 的用法。以及不要忘记有多组数据要处理。

### Problem 08. 数圈

#### 题目部分

【问题描述】

以1为中心，用2,3,4, ..., n, ..., n*n的数字围绕着中心输出数圈， 如若n=4，则

7 8 9 10

6 1 2 11

5 4 3 12

16 15 14 13

【输入形式】

一个整数n(1<=n<=10)

【输出形式】

数圈矩阵

【样例输入】

```
5
```

【样例输出】

```
21 22 23 24 25
20 7 8 9 10
19 6 1 2 11
18 5 4 3 12
17 16 15 14 13
```

#### 题解部分

【思路】

1. 正常思路，找出每一个位置上的「通项」表达，然后直接输出出来。
2. 不正常思路，也是以下 AC 代码的写法，把最大规模的数圈矩阵写进代码，然后按输入数据输出对应规模。这种方法适用于数据规模不大的情况。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P08)

【需要注意的问题】

正常思路的话需要注意动态二维数组的创建和它的指针操作，如果你没有用 `vector` 的话。不正常思路就直接把答案写进代码里……

### Problem 09. 锤子剪刀布

#### 题目部分

【问题描述】

大家应该都会玩“锤子剪刀布”的游戏。现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。

【输入形式】

输入第1行给出正整数N（<=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。

【输出形式】

输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。

【样例输入】

```
10
C J
J B
C B
B B
B C
C C
C B
J B
B C
J J
```

【样例输出】

```
5 3 2
2 3 5
B B
```

#### 题解部分

【思路】

明明是石头剪刀布好不好，怎么到你这里就变成锤子了！

把每一种情况分别进行比较，新建三个变量用于存储其中一方的胜、负、平局的次数，另外一方的胜负平局就是这一方的负胜平局次数。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P09)

【需要注意的问题】

情况有点多，分类的时候不要漏了。

### Problem 10. 绩点计算

#### 题目部分

【问题描述】

学校对本科生的成绩施行绩点制（GPA）。将学生的实际考分根据不同学科的不同学分按一定的公式进行计算。规定如下：

实际成绩        绩点

90-100          4.0

85-89            3.7

82-84            3.3

78-81            3.0

75-77            2.7

72-74            2.3

68-71            2.0

64-67            1.5

60-63            1.0

60以下            0

1.一门课程的学分绩点=该课绩点*该课学分

2.总评绩点=所有学科绩点之和/所有课程学分之和

现要求你编程求出某人的总评绩点(GPA)

【输入形式】

第一行 总的课程数n

第二行 相应课程的学分（两个学分间用空格隔开）

第三行 对应课程的实际得分

此处输入的所有数字均为整数

【输出形式】

输出有一行，总评绩点，保留两位小数

【样例输入】

```
5
4 3 4 2 3
91 88 72 69 56
```

【样例输出】

```
2.52
```

#### 题解部分

【思路】

按部就班直接计算就可以，用一个数组存储学分，一个数组存储分数。然后根据分数段分情况计算，可以使用 `if...else if...else` 结构。保留两位小数，在 C++ 中使用 `#include <iomanip>` 然后设定精度，在 Python 中直接设定精度即可。

【Accepted 代码】

- [C++ 17](https://github.com/Chen-Rain/Pitaya/tree/main/HNU-SummerTerm/T02P10)

【需要注意的问题】

浮点数除法结果的问题。

## 作业训练三

> 稍后更新题解

## 作业训练四

> 稍后更新题解

## 作业训练五

> 稍后更新题解

## 本文许可协议

<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.
