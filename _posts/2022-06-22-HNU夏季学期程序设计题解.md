---
layout:     post
title:      HNU 夏季学期「程序设计训练 2022」 课程题解
subtitle:   仅供参考
date:       2022-06-22
author:     Rain Chen
catalog: true
tags:
    - 开发与应用
---

# HNU 夏季学期「程序设计训练 2022」 课程题解

## 前言

> 「输入两个整数 a 和 b，输出它们的和。」
>           —— A+B Problem

本题解中的题目描述文字格式全部按照题目原文，描述部分的排版和题解作者无关。

## 代码

代码项目和文件存放于仓库中：

[https://github.com/Chen-Rain/Pitaya](https://github.com/Chen-Rain/Pitaya)

如果无法打开请自行检查网络配置。

## 作业训练一

### Problem 01. 众数

#### 题目部分

【问题描述】

一组数据中出现最多的数，称为众数。比如

1 2 3 3

众数为3。一组数据中也可能有多个众数，以最先出现的作为众数。比如

2 2 3 3

众数为2。

问题是一组按升序排好的数据，指出它的众数。

【输入形式】

有多组测试数据（不超过100组测试数据）。

每组测试数据占两行，第一行是正整数N：表示这组测试数据中数据项数。

第二行是N个用空格隔开的正整数，表示这组测试数据的数据元素。每个数据元素都不大于10000。

N=0，表示输入结束，并且不需要处理。

40%的测试数据N 1 ≤N≤ 10；

30%的测试数据N 10 < N≤ 100；

20%的测试数据N 100 < N≤ 1000；

10%的测试数据N 1000 < N≤ 10000；

【输出形式】

对于每组测试数据，输出一行包含一个正整数：对应的众数。

【样例输入】

```
4
1 2 3 3
4
2 2 3 3
0
```

【样例输出】

```
3
2
```

#### 题解部分

【思路】

用整型数组存储输入的要求众数的数据。根据单独输入的数字 `n` 来确定动态数组的大小。由于数组已经升序排列好了，所以不用考虑数字大小关系的问题。新建一个数组 `c[i]` 用于存储数字 `i` 的众数，这个数组应当开大一些，确保测试数据规模中的所有数字都可以在其中表示。

【Accepted 代码实现】

- C++ 17

- Python 3

[https://github.com/Chen-Rain/Pitaya](https://github.com/Chen-Rain/Pitaya)

【遇到的一些问题】

就是这 Python 的输入问题有点不方便。如果一定要使用 Python 答题的话需要仔细调整输入方式，防止在本地测试的时候可以通过，但是提交之后 WA。

### Problem 02. 开关与灯

#### 题目部分

【问题描述】

给定n个开关和m个灯，第i个开关只能打开部分灯。矩阵a包含n行m列，当aij=1时表示开关i可以打开灯j，否则aij=0。

开始时所有的m个灯都是关着的。

开关只能从状态"关"到"开"。这意味着，对于每个可以打开某个灯的开关，无论你按多少次，这个灯都是开的。

确保当你按下所有开关时，所有的灯都能打开，考虑是否可以忽略其中某个开关也能打开所有的灯。

你的任务是确定是否存在这样的开关可以忽略，而使用其余的n-1个开关来打开所有m个灯。

【输入形式】

输入第1行包含两个整数n和m(1<=n, m<=2000)，表示开关的数量和灯的数量。

接下来的n行，每行包含m个字符，字符aij=1时表示开关i可以打开灯j，否则aij=0。

【输出形式】

如果存在这样的可以忽略的开关，而使用其他n-1个开关打开所有的m个灯，输出"YES"，否则输出"NO"。

【样例输入】

```
4 5
10101
01000
00111
10000
```

【样例输出】

```
YES
```

#### 题解部分

【思路】

使用矩阵来存储开关与灯的对应关系，横向输入的时候可以用字符数组，也可以用字符串。然后每一列判断可以开灯的个数。

【Accepted 代码实现】

- C++ 17

[https://github.com/Chen-Rain/Pitaya](https://github.com/Chen-Rain/Pitaya)

【遇到的一些问题】

这道题容易出错的一点是，以为只要有矩阵的一列的数量大于 1 就可以满足去掉的条件，实际上还是要注意要判断去掉那一行之后还能不能保证所有的灯全部亮。

### Problem 03. 可删除的点

#### 题目部分

【问题描述】

平面上有n个不同的点，没有在Y轴的点，检查是否存在这样一个点，将其删除后其余所有的点均位于Y轴的同一边。

【输入形式】

输入第一行包含一个正整数n(2<=n<=105)。

接下来的n行，包含所有点的坐标，第i行包含两个整数xi和yi(|xi|、|yi|<=109，xi<>0)。

【输出形式】

如果存在这样的点，则输入"Yes"，否则输出"No"。

【样例输入】

```
3
1 1
-1 -1
2 -1
```

【样例输出】

```
Yes
```

#### 题解部分

【思路】

均在 y 轴同一边的点满足 x 轴全是正数或者全是负数。所以输入的时候最少只需要给一个变量存储所有点的 y 坐标即可，不用处理。对所有点的 x 坐标进行判断，设立一个变量记录一边的点的数量。

【Accepted 代码】

- C++ 17
 
[https://github.com/Chen-Rain/Pitaya](https://github.com/Chen-Rain/Pitaya)

【可能出错的地方】

「在 y 轴的同一边」到底是比较 x 坐标还是比较 y 坐标呢？

### Problem 04. 字符串反转 3

#### 题目部分

【问题描述】

给出一个字符串，请将其每个单词反转后输出。

【输入形式】

输入第一行为一个正整数N，表示测试用例数，接下来的N行，每行一个字符串。

【输出形式】

输出N行，每行对应一个反转后的字符串。

【样例输入】

```
3
olleh !dlrow
m'I morf .unh
I ekil .tae
```

【样例输出】

```
hello world!
I'm from hnu.
I like eat.
```

#### 题解部分

【思路】

第一眼，喔，经典字符串反转。第二眼，喔还带空格，要考虑一下输入问题。然后反转字符串第一时间想到的就是可以使用「栈」，`stack`，不过如果你第一感觉是用 `reverse()` 函数，那也没问题，不过就要考虑分段的问题了。这道题我提交的解法是使用了 `stack`，把字符串中的每一个字符进行判断，然后推入栈中，遇到空格的时候说明应该分词了，就把栈弹出，直至清空整个栈，如此往复至处理完所有数据。

【Accepted 代码】

C++ 17

[https://github.com/Chen-Rain/Pitaya](https://github.com/Chen-Rain/Pitaya)

【可能遇到的问题】

在使用 C++ 解答的时候，注意栈的大小，小心遗漏。使用 Python 解答的时候注意字符串输入的时候的问题，容易出现格式和数据类型对不上的问题。

## 作业训练二

> 稍后更新题解

## 作业训练三

> 稍后更新题解

## 作业训练四

> 稍后更新题解

## 作业训练五

> 稍后更新题解

<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.
