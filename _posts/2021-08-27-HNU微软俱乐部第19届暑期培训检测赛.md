---
layout:     post
title:      HNU 微软俱乐部第19届暑期培训检测赛题目及答案
subtitle:   「摩尔庄园，快乐童年」
date:       2021-08-27
author:     Rain Chen
header-img: img/posts.png
catalog: true
tags:
    - 开发与应用
---

# HNU 微软俱乐部第19届暑期培训检测赛题目及答案

## 信息与公告

比赛共设置2道检测题，其中题目1为基础题，题目2为提高题（对于新生而言具有一定难度，欢迎新生勇敢挑战）。

题目1针对2020级和2021级学生，成功完成题目1的学生可以获得湖南大学微软学生俱乐部免试资格，使用C++完成题目的同学获得网页组免试资格，使用Python完成题目的同学获得Python组免试资格。2020级学生C++和Python各1名指标，2021级学生C++和Python各2名指标，指标的数量将根据最后的提交结果临时调整。参考标准为比赛最终排名。

题目2针对第19届微软学生俱乐部对外群内在校成员（第19届微软学生俱乐部委员会成员除外，含全体2021级新生），成功完成题目2的同学可以获得微软俱乐部的周边帆布袋1个，取前6名（Python、C++合计6名）。

具体排名方式：在保证题目完成正确的情况下，按照线上OJ的接受时间排序。

本次比赛赛制为IOI赛制。

## 题目 A. 摩尔想钓鱼

### 问题

#### 题目描述

$2021$年的暑假到了，小摩尔们看着手游版波光粼粼的小河，觉得钓鱼比赛会是一个很完美的夏日活动。可是参加活动的摩尔数量太多了，本着爱与和平的原则，为了不让摩尔们为了争夺比赛场地而吵架，几只聪明的小摩尔决定从一条有着许多各种各样小鱼的大河修建一个主水道引河水，再通过修建小水道把主水道的河水引到每个小摩尔的家门口。考虑到美观和地形地势，这几只聪明的小摩尔决定按照由东往西的方向修建主水道，而小水道则以由北往南或由南往北的方向与主水道相连。为了更快竣工，小摩尔们想请你帮帮忙，确定主水道的最优位置并计算出最少需要多久可以修完小水道？（注意，每个摩尔家的小水道是私有的，不与其他家共用）

#### 输入格式

第一行是一个整数$n$，表示参加钓鱼比赛的摩尔数量（$0 < n < 10000$）； 第二行是一个整数$t$，表示修建一单位的小水道花费的时间（$0 < t < 10$）； 接下来$n$行是每位参赛摩尔的家的位置，每行有两个整数$x$和$y$（$-10000 < x, y < 10000$），其中$x$表示东西方向，$y$表示南北方向。

#### 输出格式

仅一行，即一个整数，代表最少需要的时间。

#### 样例

##### 样例输入

```
6
4
3 7
12 5
9 13
20 1
11 11
211 -5
```

##### 样例输出

```
120
```

#### 数据范围与提示

$$0 < n < 10000, 0 < t < 10, -10000 < x, y < 10000$$

### 答案

#### C++ 11(Clang)

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
int n, t;
int x[10001], y[10001];
int temp;
int all = 0;
int lengthm = 100000000;
int main()
{
    cin >> n;
    cin >> t;
    for (int i = 0; i < n; ++i)
    {
        cin >> x[i] >> y[i];
    }
    for (int j = 0; j < n; ++j)
    {
        temp = y[j];
        for (int k = 0; k < n; ++k)
        {
            all = abs(y[k] - temp) + all;
        }
        if (all <= lengthm)
        {
            lengthm = all;
        }
        all = 0;
    }
    cout << lengthm * t;
}

```

## 题目 B. 摩尔搭积木

### 问题

#### 题目描述

钓鱼比赛结束后，小摩尔们相约一起搭积木。每只小摩尔会将积木一块叠一块地搭成一个高柱。

这些积木块都是完美的正方体，有$n$只小摩尔分到了无限个边长为$2$的正方体积木，有$m$只小摩尔分到了无限个边长为$3$的正方体积木。由于每只小摩尔都是独一无二的，他们希望自己搭成高柱的高度也是独一无二的。小摩尔们想请你帮帮忙，算一算所有摩尔们搭成高柱的最大高度的最小值。

需要注意的是，高柱的高度不能为$0$，积木不可分割。

#### 输入格式

输入仅有一行，为两个非负整数$n$和$m$（$0 \leq n, m \leq 1000000, n + m > 0$），用一个空格隔开。

#### 样例

##### 样例输入 1

```
3 2
```

##### 样例输出 1

```
8
```

##### 样例输入 2

```
114514 2333
```

##### 样例输出 2

```
229028
```

#### 数据范围与提示

$$0 \leq n, m \leq 1000000, n + m > 0$$

### 答案

#### C++ 17(Clang)

这是其中一种答案：

```cpp
#include <iostream>
#include <set>
using namespace std;
int main()
{
    set<int> s;
    set<int> s1;
    int n, m;
    cin >> n >> m;
    int *arr = new int[m + n];
    int m1 = 1;
    int n1 = 0;
    while (n1 < m + n)
    {
        if (m1 % 2 == 0 || m1 % 3 == 0)
        {
            arr[n1] = m1;
            n1++;
        }
        m1++;
    }
    if (m < n)
    {
        int max1 = 0;
        int i = 1;
        int j = 0;
        for (int i = 0; i < n + m; i++)
        {
            if (arr[i] % 2 != 0 && arr[i] % 3 == 0)
            {
                s.insert(arr[i]);
                if (arr[i] > max1)
                    max1 = arr[i];
                j++;
            }
        }
        j = m - j;
        for (int i = 0; i < n + m; i++)
        {
            if (j <= 0)
                break;
            if (arr[i] % 2 == 0 && arr[i] % 3 == 0)
            {
                s.insert(arr[i]);
                j--;
                if (arr[i] > max1)
                    max1 = arr[i];
            }
        }
        i = 1;
        j = 0;
        int num = 0;
        while (j != n)
        {
            if (i % 2 == 0 && s.count(i) == 0)
            {
                if (i > max1)
                    max1 = i;
                j++;
            }
            i++;
        }
        cout << max1 << endl;

    }
    else
        cout << 3 * m << endl;
}

```

#### C++11

这是另一种答案：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
int main()
{
    int n, m;
    scanf("%d %d", &n, &m);
    int num1 = 0, num2 = 0, temp = 0, i;
    for (i = 2; num1 < n || num2 < m || num1 + num2 - temp < n + m; i++)
    {
        if (i % 2 == 0) num1++;
        if (i % 3 == 0) num2++;
        if (i % 6 == 0) temp++;
    }
    printf("%d", i - 1);
    return 0;
}

```